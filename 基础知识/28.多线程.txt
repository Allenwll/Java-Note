			Java多线程
		 
				java.lang
				
		Java程序有主线程 称为main线程  
		
		Thread.currentThread().getName() 可以得到当前执行该方法的线程的名字
		
	实现多线程:
	
		1.继承Thread类
	
			可以通过创建 Thread 的实例来创建新的线程。
		
			每个线程都是通过某个特定Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。

			通过调用Thead类的start()方法来启动一个线程。
				
			缺点：
	
			如果类已经从一个类继承（如小程序必须继承自 Applet 类），则无法再继承 Thread 类
		
		2.通过Runnable接口实现多线程
	
			优点：可以同时实现继承。 可以实现线程间数据共享
		
	非线程安全：
		
			多个线程同时访问一个数据，造成了数据不同步，CPU时间片造成的
	
	线程状态
		
		新生状态
			
			用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。
			
			处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）
		就绪状态
			
			处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU。
			
			等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，
			
			系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。
		
		运行状态
			
			在运行状态的线程执行自己的run方法中代码，直到调用其他方法而终止、或等待某资源而阻塞或完成任务而死亡。
			
			如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态。
			
		
		阻塞状态(sleep/yield/join方法)
		
			处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入阻塞状态。 
			
			在阻塞状态的线程不能进入就绪队列。
		
			只有当引起阻塞的原因消除时 线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。
	
		有三种方法可以暂停Threads执行：
			
			1.sleep方法：
					
					Sleep时别的线程也不可以访问锁定对象。
			
			2.yield方法: 
			
				让出CPU的使用权，从运行态直接进入就绪态。让CPU重新挑选哪一个线程进入运行状态。
			
			3.join方法: 
			
					当某个线程等待另一个线程执行结束后，才继续执行时，
					
					使用join方法。使调用该方法的线程在此之前执行完毕，也就是等待调用该方法的线程执行完毕后再往下继续执行
		
		死亡状态
			
			死亡状态是线程生命周期中的最后一个阶段。
			
			线程死亡的原因有两个。
			
				一个是正常运行的线程完成了它的全部工作；
				
				另一个是线程被强制性地终止
				
					如通过执行stop或destroy方法来终止一个线程
						不推荐使用这两个方法。前者会产生异常，后者是强制终止，不会释放锁。
						
		当一个线程进入死亡状态以后，就不能再回到其它状态了。

		让一个Thread对象重新执行一次的唯一方法，就是重新产生一个Thread对象。	

	
	
	
	方  法			功       能
	
	isAlive()	判断线程是否还“活”着，即线程是否还未终止。
	
	getPriority()	获得线程的优先级数值

	setPriority()	设置线程的优先级数值
		
	setName()	给线程一个名字
	
	getName()	取得线程的名字
	
	setDaemon() 守护线程  生命周期取决于前台线程  在创建对象之后哦，start方法调用之前
	
	currentThread()	取得当前正在运行的线程对象，也就是取得自己本身
	
调度器
		Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。
		
		线程调度器按照线程的优先级决定应调度哪个线程来执行。
 		
		线程的优先级用数字表示，范围从1到10  一个线程的缺省优先级是5
		
		优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高后调用优先级低的线程。
		
死锁和同步问题

	由于同一进程的多个线程共享同一片存储空间，在带来方便的同时，也带来了访问冲突这个严重的问题。
	
	Java语言提供了专门机制以解决这种冲突，有效避免了同一个数据对象被多个线程同时访问。
	
	互斥锁原理。利用互斥锁解决临界资源问题
	 
	这套机制就是 synchronized 关键字它包括两种用法： 
	
		synchronized 方法和 synchronized 块
　		
		1. synchronized 方法： 有锁 等待， 无锁，加锁， 进入，退出，解锁
		
				通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。
			
　　				public  synchronized [同步的方法必须获得对象的锁才能运行。普通方法不获得锁也可以运行。] void accessVal(int newVal); 

			synchronized 方法控制对类成员变量的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行
			
			否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得 该锁，重新进入可执行状态。
　
			缺陷：
			
				若将一个大的方法声明为synchronized 将会大大影响效率，
			
				典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。
			

		2. synchronized 块：通过 synchronized关键字来声明synchronized 块。语法如下：
				
				private static Object syncObject=new Object();
		
　			　synchronized(syncObject)　{ 　//允许访问控制的代码 }  syncObject 是一个引用类型的对象  该对象必须唯一   

如何解决死锁问题：
	
	1.往往是程序逻辑的问题。需要修改程序逻辑。
	
	2.尽量不要同时持有两个对象锁。
	
		使用同步的思路解决多线程问题更 加有效，更加节约系统的资源。 
	
		同步解决问题的另一种典型方式：生产者/消费者[生产者和消费者共享了SyncStack对象。一个从里面拿东西，一个从里面消费东西。
		
		生产者线程只负责生产，消费者线程只负责消费，在消费者发现无内容可消费时则睡觉。

注意点
	
	new :创建好线程对象,但没有启动的时候.	
	
	一个线程调用start()之后不一定会马上启动,此时进入就绪状态,等待得到资源.
	
	就绪线程通过Scheduler(调度程序)去确定是否运行.
	
	Runing---dead:运行结束(非双向,为单向箭头)
	
	Runing---就绪:暂停(除了没有CPU,具备运行的所有条件)
	
	Runing-otherwise(阻塞):因程序原因:调用sleep或join之后,线程被阻塞.这时不具备运行的条件,此时线程进入阻塞池.sleep或join条件解除之后直接进入Runnable不进入running.
	
	Lock pool:锁池状态。每个对象都有自己的锁池，锁池里放置了想获得对象锁的线程。
		
	等待状态(wait pool)：比如一个线程调用了某个对象的wait()方法，就进入了该对象的wait pool, 正在等待其它线程调用这个对象的notify()或者notifyAll()（这两个方法同样是继承自Object类）方法来唤醒它；

	
进程间的相互作用

		线程之间需要一些协调通信，来共同完成一件任务。 需要 wait notify和notifyAll方法
		
		因为wait和notify方法定义在Object类中，因此会被所有的类所继承。

		这些方法都是final的，即它们都是不能被重写的，不能通过子类覆写去改变它们的行为。
	
	wait()方法

　　		wait()方法使得当前线程必须要等待，等到另外一个线程调用notify()或者notifyAll()方法。

　　		当前的线程必须拥有当前对象的monitor，也即lock，就是锁。

　　				线程调用wait()方法，释放它对锁的拥有权，

				然后等待另外的线程来通知它（通知的方式是notify()或者notifyAll()方法）
				
				这样它才能重新获得锁的拥有权和恢复执行。

　　				要确保调用wait()方法的时候拥有锁，
				
				即，wait()方法的调用必须放在synchronized方法或synchronized块中。

　　			当线程调用了wait()方法时，它会释放掉对象的锁。
			
			另一个会导致线程暂停的方法：Thread.sleep()，它会导致线程睡眠指定的毫秒数，
			
			但线程在睡眠的过程中是不会释放掉对象的锁的。
 
	notify()方法

　		　notify()方法会唤醒一个等待当前对象的锁的线程。

　　		如果多个线程在等待，它们中的一个将会选择被唤醒。

		这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait方法中的一个）。

　　		被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁。

　　		被唤醒的线程将和其他线程以通常的方式进行竞争，来获得对象的锁。

		也就是说，被唤醒的线程并没有什么优先权，也没有什么劣势，对象的下一个线程还是需要通过一般性的竞争。

　　		notify()方法应该是被拥有对象的锁的线程所调用。
		
		和wait()方法一样，notify方法调用必须放在synchronized方法或synchronized块中。


　　	wait()和notify()方法要求在调用时线程已经获得了对象的锁

	因此对这两个方法的调用需要放在synchronized方法或synchronized块中。

一个线程变为一个对象的锁的拥有者是通过下列三种方法：

　　1.执行这个对象的synchronized实例方法。

　　2.执行这个对象的synchronized语句块。这个语句块锁的是这个对象。

　　3.对于Class类的对象，执行那个类的synchronized、static方法。

 