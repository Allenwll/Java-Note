> ### JVM内存结构主要有三大块: **堆内存、方法区、栈**

1.  堆内存 heap
> 年轻代 比例8:1:1 
> 
> > Eden
> > 
> > From Survivor
> > 
> > To Survivor
> 
> 老年代

2.方法区 别名Non-Heap 非堆

> 存储类信息、常量、静态变量等数据 属于线程共享的区域

3.栈 stack 先进后出 

> Java虚拟机栈
> 
> 本地方法栈
> 
> 程序计数器

4.寄存器

> JAVA中只使用四个寄存器,因为如果使用的寄存器数多于处理器端口数，那么处理器的效率将严重地降低
> 
> 所有进程都使用寄存器，Java虚拟机使用寄存器管理系统堆栈
> 
> > 1.程序记数寄存器：跟踪程序执行的准确位置
> > 
> > 2.堆栈指针寄存器：指示操作栈项
> > 
> > 3.框架寄存器：指向当前执行的环境
> > 
> > 4.变量寄存器：指向当前执行环境中第一个本地变量
> 
> Java程序向JVM传递字节码,JVM每个方法创建堆栈框架，每个框架维护三种信息：
> 
> > 局部变量：由变量寄存器指向的32位变量数组
> > 
> > 执行环境：由框架寄存器指向和执行的方法
> > 
> > 操作堆栈：执行先进先出规则（FIFO），它是32位宽度的，它为操作码维护必要的参数，该堆栈的顶部是由堆栈指针寄存器索引的
> 
> 是速度最快的存储场所,因为寄存器位于处理器内部,不过寄存器个数是有限的
> 
> 在内存中是由编译器根据需要来分配的
> 
> 开发人员不能够通过代码来控制这个寄存器的分配

## JVM控制参数

*   -Xms设置堆的最小空间大小

*   -Xmx设置堆的最大空间大小

*   -XX:NewSize设置新生代最小空间大小

*   -XX:MaxNewSize设置新生代最大空间大小

*   -XX:PermSize设置永久代最小空间大小

*   -XX:MaxPermSize设置永久代最大空间大小

*   -Xss设置每个线程的堆栈大小

_没有直接设置老年代的参数 可通过堆大小减去年轻代大小控制_

## JVM和系统调用关系

`Class文件—————> 类加载器 Class Loader<————>运行时数据区<———————>执行引擎 Execution Engine 、本地接口 Native Interface 、本地库Native Libraries`

**运行时数据区**

1.非线程共享

*   Java栈 Java Stack
> 生命周期与线程相同,描述的是Java方法执行的内存模型
> 
> 每个方法被执行时会创建一个Stack Frame栈帧用于存放局部变量表(基本类型)、操作栈、动态链接、方法出口等信息
> 
> 每一个方法被调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程
> 
> 错误信息是StackOverflowError和OutOfMemoryError异常

*   本地方法栈 Native Method Stack
> 所用相似，不过JavaStack为JVM执行Java方法(即字节码)服务，本地方法栈为JVM使用到的Native方法服务
> 
> 错误信息是StackOverflowError和OutOfMemoryError异常

*   程序计数器 Program Counter Register
> 当前线程所执行的字节码的行号指示器
> 
> 唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域

2.线程共享

*   方法区 Method Area
> 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
> 
> 当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常[条件非常苛刻]

*   堆 Heap GC堆
> 内存最大 存放对象实例   内存回收采用分代收集算法
> 
> 没有内存完成实例分配，并且堆无法再扩展，抛出OutOfMemoryError异常