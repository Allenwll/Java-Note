## -.JVM之类加载机制

### 类加载

1.将类的.class文件中的二进制数据读入内存，将其放在运行时的方法区内.

2.在堆内创建一个**java.lang.Class**对象,用来封装类在方法区内的数据结构.

3.Class对象封装了类在方法区内的数据结构,并且向Java程序员提供了访问方法区内的数据结构的接口

_类加载器可以预加载（类将要被使用前） 若预加载过程中遇到错误，须在程序首次主动使用该类是才报告错误(**LinkageError**)，不使用不报错_

### 加载.class文件的方式

1.从本地系统中直接加载

2.通过网络下载.class文件

3.从zip、jar等归档文件中加载.class文件

4.从专有数据库中提取.class文件

## 二.类的生命周期

 **类加载过程**

> > 加载Loading-&gt;验证Verification-&gt;准备Preparation——&gt;解析Resolution-&gt;初始化

 **类生命周期**

> > -&gt;类初始化-&gt;使用Using-&gt;卸载Unloading

 _类加载五个阶段中解析阶段不确定其顺序，可以在初始化之后开始{动态绑定或晚期绑定} 上述五个阶段是按顺序开始，并不是按顺序进行或完成，因为通常为互相交叉混合进行_

 1.加载 类加载器可自定义

*   通过一个类的全限定名来获取其定义的二进制字节流

*   将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

*   在堆中生成一个Class对象，作为对方法区中数据的访问入口

2.验证 确保被加载类的正确性

*   文件格式验证: 验证字节流是否符合Class文件格式的规范

*   元数据验证: 对字节码描述的信息进行语义分析,以确保其描述的信息符合Java规范的要求

*   字节码验证: 通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的

*   符号引用验证: 确保解析动作能正确执行

    _缩短虚拟机类加载的时间可用**Xverifynone**参数来关闭大部分类验证措施_

3.准备 为类的**静态变量**分配内存,并将其初始化为默认值

*   进行分配的仅包括类变量(static) 不包括实例变量，实例变量会在对象实例化时随着对象一起分配在堆中

*   设置初始值通常指数据类型默认的值,而不是在Java代码中显示赋予的值

    _public static int value = 3;  此时 value的值为0_

    _value为3是在是在程序编译后,存放在类构造器**&lt;clinit&gt;**方法中的 准备阶段未执行任何Java方法,初始化时才执行_

*   如果是常量则会被初始化成指定的值

4.解析 把类中的符号引用转化为直接引用

*   解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程.解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行&gt; 符号引用:一组符号来描述目标，可以是任何字面量直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄

5.初始化 为类的静态变量赋予正确的初始值,JVM负责对类进行初始化

> 声明类变量时指定初始值
> 
> 使用静态代码块为类变量指定初始值

**JVM初始化步骤**

a. 若该类未被加载和连接,则程序先加载并连接该类

b. 若该类的直接父类未被初始化,则先初始化其直接父类

c. 若类中有初始化语句,则系统依次执行这些初始化语句

**类初始化：** 对类主动使用时才会初始化类

1.创建类的实例 new

2.访问某个类或者接口的静态变量,或者对该静态变量赋值

3.调用类的静态方法

4.反射 **Class.forName()**

5.初始化某个类的子类,则父类也会被初始化

6.Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用(java.exe)命令来运行某个主类

**结束生命周期**

 1.执行了**System.exit()**

 2.程序正常执行结束

 3.程序在执行过程中遇到异常或错误而终止

 4.操作系统出现错误导致JVM进程终止