# 处理器

> 多任务和高并发是衡量一台计算器处理器能力的重要指标之一
> 
> 一般衡量一个服务器性能的高低，使用每秒事务处理数Transaction Per Second TPS这个指标比较能说明问题
> 
> TPS 代表着一秒内服务器平均能响应的请求数,与程序的并发能力有着密切的关系
> 
> RT 响应时间是指系统对请求作出响应的时间
> 
> Throughput 吞吐量是指系统在单位时间内处理请求的数量
> 
> 并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量
> 
> QPS每秒查询率(Query Per Second)  
> 
> 并发数： 系统同一时候处理的request/事务数
> 
> QPS（TPS）= 并发数/平均响应时间  
> 
> 并发数 = QPS*平均响应时间
> 
> # 并发编程:
> 
> java内存模型，volatile以及CAS算法

## 1.Java内存模型  JMM  共享内存模型

> JMM决定一个线程对共享变量的写入何时对另一个线程可见。
> 
> > JMM定义了线程和主内存之间的抽象关系：
> > 
> > > 线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），
> > > 
> > > 本地内存中存储了该线程以读/写共享变量的副本。
> > > 
> > > 本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

## 2.volatile 解决可见性

> JVM必须要解决可见性和同步机制才能计算正确，否则当多线程并发的时候，不能得到预期的结果

### 可见性

> 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
> 
> 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
> 
> > 通过synchronized和Lock也能够保证可见性
> > 
> > synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中
> 
> 而普通的共享变量不能保证可见性
> 
> > 因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值

## 3.原子操作

### 1.处理器实现原子操作流程

> 32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作
> 
> Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子
> 
> 首先处理器会自动保证基本的内存操作的原子性。
> 
> > 1.处理器保证从系统内存中读取或者写入一个字节是原子的
> > 
> > 2.意思是当一个处理器读取一个字节时,其他处理器不能访问这个字节的内存地址
> > 
> > 1.复杂的内存操作处理器是不能自动保证其原子性的
> > 
> > 2.比如跨总线宽度、跨多个缓存行和跨页表的访问。提供总线锁定和缓存锁定两个机制来解决
> 
> 1.总线锁定
> 
> > 总线锁就是使用处理器提供的一个LOCK#信号
> > 
> > 当一个处理器在总线上输出此信号时,其他处理器的请求将被阻塞住,那么该处理器可以独占共享内存。
> 
> 2.缓存锁定
> 
> > 1.在同一时刻,我们只需保证对某个内存地址的操作是原子性即可
> > 
> > 2.但总线锁定把CPU和内存之间的通信锁住了,这使得锁定期间,其他处理器不能操作其他内存地址的数据,所以总线锁定的开销比较大
> > 
> > 1.频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里,那么原子操作就可以直接在处理器内部缓存中进行,并不需要声明总线锁
> > 
> > 2.在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。
> > 
> > > 3.所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中,并且在Lock操作期间被锁
> > 
> > 4.那么当它执行锁操作回写到内存时,处理器不在总线上声言LOCK#信号
> > 
> > 5.而是修改内部的内存地址,并允许它的缓存一致性机制来保证操作的原子性
> > 
> > 6.因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据,当其他处理器回写已被锁定的缓存行的数据时,会使缓存行无效,
> > 
> > 有两种情况不会使用缓存指定
> > 
> > > 1.当操作的数据不能被缓存在处理器内部或操作的数据跨多个缓存行(cache line)时,则处理器会调用总线锁定
> > > 
> > > 2.有些处理器不支持缓存锁定。
> > > 
> > > > 对于Intel 486和Pentium处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定
> > > 
> > > 针对以上两个机制,我们通过Intel处理器提供了很多Lock前缀的指令来实现
> > > 
> > > 例如位测试和修改指令:BTS、BTR、BTC;交换指令XADD、CMPXCHG,以及其他一些操作数和逻辑指令(如ADD、OR)等
> > > 
> > > 被这些指令操作的内存区域就会加锁,导致其他处理器不能同时访问它

### Java实现原子操作

> 使用循环CAS实现
> 
> > JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的
> > 
> > CAS操作使用计算机原语实现。
> > 
> > 自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止
> 
> CAS是由CPU硬件实现，所以执行相当快.
>
> CAS有三个操作参数：内存地址，期望值，要修改的新值
>>当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过
>>这时候失败返回，当相等的时候，将内存中的值改为新的值，并返回成功
>
> CAS存在3大问题:
> 
> > 1.ABA问题
> > 
> > > CAS需要在操作值的时候,检查值有没有发生变化,如果没有发生变化则更新
> > > 
> > > 但是如果一个值原来是A,变成了B,又变成了A,那么使用CAS进行检查时会发现它的值没有发生变化,但是实际上却变化了
> > > 
> > > 解决思路就是使用版本号,在变量前面追加上版本号,每次变量更新的时候把版本号加1
> > 
> > 2.循环时间长开销大
> > 
> > > 自旋CAS如果长时间不成功,会给CPU带来非常大的执行开销
> > > 
> > > 如果JVM能支持处理器提供的pause指令,那么效率会有一定的提升
> > > 
> > > pause指令有两个作用:
> > > 
> > > > 1.可以延迟流水线执行指令(de-pipeline),使CPU不会消耗过多的执行资源
> > > > 
> > > > 2.可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush),从而提高CPU的执行效率
> > 
> > 3.只能保证一个共享变量的原子操作
> > 
> > > 多个共享变量操作可用锁来保证
> > > 
> > > 也可把多个共享变量合并成一个共享变量操作

**AtomicReference 解决上述问题**